% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R, R/rk.R
\name{crk}
\alias{crk}
\alias{rk}
\title{Update \eqn{k}}
\usage{
crk(prior_mu, prior_var, v, y, jsize, jtime, mu, theta, sigma_v, rho, h)

rk(prior_mu, prior_var, v, y, jsize, jtime, mu, theta, sigma_v, rho, h)
}
\arguments{
\item{prior_mu}{conjugate prior mean.}

\item{prior_var}{conjugate prior variance.}

\item{v}{vector of volatility \[\eqn{v_0, v_1, ..., v_N}\].}

\item{y}{vector of returns \[\eqn{y_1, ..., y_N}\].}

\item{jsize}{vector of jump sizes \[\eqn{J_1, ..., J_N}\]}

\item{jtime}{vector of jump indicators \[\eqn{I_1, ..., I_N}\], I_n = 1 or 0.}

\item{mu}{parameter \eqn{\mu}.}

\item{theta}{parameter \eqn{\theta}.}

\item{sigma_v}{parameter \eqn{\sigma_v}.}

\item{rho}{parameter \eqn{\rho}.}

\item{h}{time unit.}
}
\value{
new value for \eqn{k}, a scale value.
}
\description{
Parameter \eqn{k} has a normal posterior if its prior is also a normal.
We generate new \eqn{k} from its posterior.
* `crk()` implemented in C++, through package Rcpp.
* `rk()` implemented in R.
}
\details{
Employ the following version of SVJ model
\deqn{y_n=\mu h - \frac{1}{2}v_{n-1}h + \sqrt{v_{n-1}h}\epsilon_n^y + J_nI_n}
\deqn{v_n-v_{n-1}=k(\theta-v_{n-1})h + \sigma_v\sqrt{v_{n-1}h}
     (\rho\epsilon_n^y + \sqrt{1-\rho^2}\epsilon_n)}
We have
\deqn{x_n = k(\theta-v_{n-1})h +
           \sigma_v\sqrt{1-\rho^2}\sqrt{v_{n-1}h}\epsilon_n}
\deqn{x_n|v_{n-1},v_n,y_n,J_n,I_n \sim \mathcal{N}(k(\theta-v_{n-1})h,
                                        \sigma_v^2(1-\rho^2)v_{n-1}h)}
where
\deqn{x_n\triangleq v_n-v_{n-1}-\sigma_v\rho\sqrt{v_{n-1}h}\epsilon_n^y
, \qquad
\sqrt{v_{n-1}h}\epsilon_n^y=y_n-\mu h +\frac{1}{2}v_{n-1}h - J_nI_n.}
Noting that
1. above representation is robust even for case \eqn{\theta-v_{n-1}=0};
2. `Inf * 0` produces `NaN`, which may happen if we define
\eqn{x_n^{'}\triangleq x_n/((\theta-v_{n-1})h)}.

The posterior
\deqn{\begin{matrix}
      P(k|v_{0:N},y_{1:N},J_{1:N},I_{1:N})
      &\propto& P(v_{0:N},y_{1:N},J_{1:N},I_{1:N}) \cdot P(k)\\
      &\propto&\prod_{n=1}^N(P(y_n|v_{n-1},J_n,I_n)P(v_n|v_{n-1},y_n,J_n,I_n) )
      \cdot P(k)\\
      &\propto&\prod_{n=1}^NP(v_n|v_{n-1},y_n,J_n,I_n)\cdot P(k)\\
      &\propto&\prod_{n=1}^NP(x_n|v_{n-1},y_n,J_n,I_n)\cdot P(k)
      \end{matrix}}
is a normal when the prior \eqn{P(k)=\mathcal{N}(\mu_0,\sigma_0^2)}.
The posterior parameters are updated iteratively as
\deqn{\sigma_{post}^{2} = \left(\frac{1}{\sigma_0^2} +
      \frac{(\theta-v_{n-1})^2h}{\sigma_v^2(1-\rho^2)v_{n-1}} \right)^{-1},}
\deqn{\mu_{post} = \sigma_{post}^{2}
                      \left(\frac{\mu_0}{\sigma_0^2}+
      \frac{x_n(\theta-v_{n-1})}{\sigma_v^2(1-\rho^2)v_{n-1}}\right).}
* n=1, compute \eqn{\mu_{post}, \sigma_{post}^2} based on \eqn{v_{n-1},v_n}
 and \eqn{\mu_0, \sigma_0^2}.
* update prior parameters as
\eqn{\mu_0=\mu_{post}, \sigma_0^2=\sigma_{post}^2}.
* \eqn{n\ge 2}, repeat above computation until n=N.

Generate new \eqn{k} using the latest \eqn{\mu_{post}} and
\eqn{\sigma_{post}^2} in above repetitve computation.
}
\examples{
v = rep(0.25,5)
y = rep(0.125,4)
mu = 0; theta = 0.25; sigma_v = 0.1; rho = 0
h = 1
jsize = rnorm(4, mean=0, sd=0.5)
jtime = rbinom(4, size=1, prob=0.01)
rk(0.01,1,v,y, jsize, jtime, mu,theta,sigma_v,rho,h)
}
