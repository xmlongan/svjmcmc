# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @rdname initialize_values
cinitialize_values <- function(y, ini_par, h) {
    .Call(`_svjmcmc_cinitialize_values`, y, ini_par, h)
}

#' @rdname mcmc
cmcmc <- function(y, ini_par, g = 5000L, G = 10000L, h = 1, echo = 0) {
    .Call(`_svjmcmc_cmcmc`, y, ini_par, g, G, h, echo)
}

#' @rdname rjsize_i
crjsize_i <- function(jtime_i, vim1, vi, yi, mu, k, theta, sigma_v, rho, lmbd, sigma_j, h) {
    .Call(`_svjmcmc_crjsize_i`, jtime_i, vim1, vi, yi, mu, k, theta, sigma_v, rho, lmbd, sigma_j, h)
}

#' @rdname rjtime_i
crjtime_i <- function(jsize_i, vim1, vi, yi, mu, k, theta, sigma_v, rho, lmbd, sigma_j, h) {
    .Call(`_svjmcmc_crjtime_i`, jsize_i, vim1, vi, yi, mu, k, theta, sigma_v, rho, lmbd, sigma_j, h)
}

#' @rdname rk
crk <- function(prior_mu, prior_var, v, y, jsize, jtime, mu, theta, sigma_v, rho, h) {
    .Call(`_svjmcmc_crk`, prior_mu, prior_var, v, y, jsize, jtime, mu, theta, sigma_v, rho, h)
}

#' @rdname rlambda
crlambda <- function(prior_a, prior_b, jtime) {
    .Call(`_svjmcmc_crlambda`, prior_a, prior_b, jtime)
}

#' @rdname rmu
crmu <- function(prior_mu, prior_var, v, y, jsize, jtime, k, theta, sigma_v, rho, h) {
    .Call(`_svjmcmc_crmu`, prior_mu, prior_var, v, y, jsize, jtime, k, theta, sigma_v, rho, h)
}

#' @rdname rrho
crrho <- function(rho_old, v, y, jsize, jtime, mu, k, theta, sigma_v, h) {
    .Call(`_svjmcmc_crrho`, rho_old, v, y, jsize, jtime, mu, k, theta, sigma_v, h)
}

#' @rdname rsigma_j
crsigma_j <- function(prior_shape, prior_scale, jsize) {
    .Call(`_svjmcmc_crsigma_j`, prior_shape, prior_scale, jsize)
}

#' @rdname rsigma_v
crsigma_v <- function(sigma_v_old, prior_shape, prior_rate, v, y, jsize, jtime, mu, k, theta, rho, h) {
    .Call(`_svjmcmc_crsigma_v`, sigma_v_old, prior_shape, prior_rate, v, y, jsize, jtime, mu, k, theta, rho, h)
}

#' @rdname rtheta
crtheta <- function(prior_mu, prior_var, v, y, jsize, jtime, mu, k, sigma_v, rho, h) {
    .Call(`_svjmcmc_crtheta`, prior_mu, prior_var, v, y, jsize, jtime, mu, k, sigma_v, rho, h)
}

#' @rdname rv0
crv0 <- function(v0_old, prior_shape, prior_rate, v1, y1, jsize_1, jtime_1, mu, k, theta, sigma_v, rho, h) {
    .Call(`_svjmcmc_crv0`, v0_old, prior_shape, prior_rate, v1, y1, jsize_1, jtime_1, mu, k, theta, sigma_v, rho, h)
}

#' @rdname rvN
crvN <- function(vN_old, vNm1, yN, jsize_N, jtime_N, mu, k, theta, sigma_v, rho, h) {
    .Call(`_svjmcmc_crvN`, vN_old, vNm1, yN, jsize_N, jtime_N, mu, k, theta, sigma_v, rho, h)
}

#' @rdname rvi
crvi <- function(vi_old, vim1, vip1, yi, yip1, jsize_i, jsize_ip1, jtime_i, jtime_ip1, mu, k, theta, sigma_v, rho, h) {
    .Call(`_svjmcmc_crvi`, vi_old, vim1, vip1, yi, yip1, jsize_i, jsize_ip1, jtime_i, jtime_ip1, mu, k, theta, sigma_v, rho, h)
}

#' Generate SVJ Sample Trajectory
#'
#' @description
#' Generate SVJ sample trajectory using Euler
#' Approximation.
#'
#' @details
#' SVJ:
#' \deqn{y_n=\mu h -\frac{1}{2}v_{n-1}h + \sqrt{v_{n-1}h}(\rho\epsilon_n^v
#'       +\sqrt{1-\rho^2}\epsilon_n) + J_nI_n,}
#' \deqn{v_n-v_{n-1}=k(\theta-v_{n-1})h + \sigma_v\sqrt{v_{n-1}h}\epsilon_n^v.}
#'
#' @param v_0 the initial volatility \eqn{v_0}.
#' @param n_segment number of further segments for each interval.
#' @param par a vector of true values for the parameters
#' \eqn{\mu,k,\theta,\sigma_v,\rho,\lambda,\mu_j,\sigma_j}.
#' @param N the number of sample returns, \eqn{y_1,\cdots,y_N}.
#' @param h time unit.
#'
#' @return a vector of returns, \eqn{(y_1,\cdots,y_N)}.
#' @export
#'
#' @examples
#' S0 = c(0.125,0.1,0.25,0.1,-0.7, 0.1, 0.0, 0.5)
#' y_series_0 = crSVJ(v_0=S0[3], n_segment=10, par=S0, N=1000, h=1)
#'
#' S1 = c(0.4,0.1,0.25,0.1,-0.7, 0.1, 0.0, 0.5)
#' y_series_1 = crSVJ(v_0=S1[3], n_segment=10, par=S1, N=1000, h=1)
#'
#' S2 = c(0.125,0.03,0.25,0.1,-0.7, 0.1, 0.0, 0.5)
#' y_series_2 = crSVJ(v_0=S2[3], n_segment=10, par=S2, N=1000, h=1)
#'
#' S3 = c(0.125,0.1,0.5,0.1,-0.7, 0.1, 0.0, 0.5)
#' y_series_3 = crSVJ(v_0=S3[3], n_segment=10, par=S3, N=1000, h=1)
#'
#' S4 = c(0.125,0.1,0.25,0.2,-0.7, 0.1, 0.0, 0.5)
#' y_series_4 = crSVJ(v_0=S4[3], n_segment=10, par=S4, N=1000, h=1)
#'
#' S5 = c(0.125,0.1,0.25,0.1,-0.3, 0.1, 0.0, 0.5)
#' y_series_5 = crSVJ(v_0=S5[3], n_segment=10, par=S5, N=1000, h=1)
crSVJ <- function(v_0, n_segment, par, N, h = 1) {
    .Call(`_svjmcmc_crSVJ`, v_0, n_segment, par, N, h)
}

#' Generate and Write to Files Large Number of Sample Trajectories
#'
#' @description
#' Generate and Write to Files Large Number of Sample Trajectories. The files
#' are named according to 'par_name-N-ith.csv' where N denotes sample length.
#'
#' @param par_name parameter setting name, such as 'par0'.
#' @param par a vector of true values for the parameters
#' \eqn{\mu,k,\theta,\sigma_v,\rho,\lambda,\mu_j,\sigma_j}.
#' @param N the number of sample returns, \eqn{y_1,\cdots,y_N}.
#' @param N_rep the number of Sample Trajectories.
#' @param h time unit, defaults to 1.
#' @param n_segment number of further segments for each interval,
#' defaults to 10.
#'
#' @return no return.
#' @export
#'
#' @examples
#' # par0 = c(0.125,0.1,0.25,0.1,-0.7, 0.1, 0.0, 0.5)
#' # gen_data('par0', par0, N=100000, N_rep=0, h=1, n_segment=10)
gen_data_SVJ <- function(par_name, par, N, N_rep, h = 1, n_segment = 10) {
    invisible(.Call(`_svjmcmc_gen_data_SVJ`, par_name, par, N, N_rep, h, n_segment))
}

